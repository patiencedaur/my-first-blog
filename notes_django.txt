urlresolver - штука на сервере, которая определяет, какой адрес в строке (ориентируется по urls.py - внутри него объект URLconf)
urls.py устанавливает соответствия между адресами и представлениями (как выглядит на сайте)
если совпадает, передаётся команде view
view проверяет разрешения и генерирует ответы

виртуальное окружение изолирует зависимости python/django для каждого отдельного сайта
myvenv\Scripts\activate

настройки - в mysite/settings.py

миграция - это перемещение базы данных (нельзя просто так взять и переместить)
python manage.py migrate

У объекта бывают свойства и методы
Запись в блоге - это объект
python manage.py startapp blog

Имена классов пишутся с большой буквы
class Post(models.Model)

имена функций: маленькие буквы, подчёркивание вместо пробела
def publish(self)
def - создаётся функция или метод
self - это нужно проделать с самим объектом
return работает так же, как в си, но не нужно указывать тип

после создания модели нужно создать в базе данных новые связи (показать сайту, что у нас есть новая модель!)
python manage.py makemigrations blog
python manage.py migrate blog

теперь добавляем и "регистрируем" новую модель в панель управления admin.py

python manage.py createsuperuser

можно загрузить всё в git
из гита можно загрузить на сайт (pythonanywhere.com)
на сайте тоже можно сделать виртуальное окружение
туда загружается питон, джанго, делается миграция и суперъюзер

управление сайтом (веб-приложением): web > название сайта

WSGI - питоновский протокол обслуживания сайтов
конфигурацию WSGI нужно редактировать
если ошибка, смотреть лог (во вкладке веб)

""" здесь комментарий (docstring) """
# а вот так - одна строчка комментария


Регекспы (можно задать шаблон)
r'выражение' - "raw" (не надо интерпретировать)
^ начало текста
$ конец текста
\d цифра
+ повторить предыдущий элемент как минимум 1 раз
() отделяет часть шаблона

Пример: ^post/(\d+)/$ - адреса типа post/1235/
^post/ урл должен начинаться с post/
(\d+) несколько цифр

^$ - пустая строка

в urls.py в основной директории django прописывается, куда обращаться за урлами. а обращаться надо в blog/urls.py (то есть файл, принадлежащий к нашему сайту)
в blog/urls.py делается связь с просто urls.py и представлениями (views)
какой урл связан с какой вьюхой? пока там условно написано post_list, но самого пост-листа нет, поэтому нормально, что выскакивает ошибка.

откуда куда запрашивается инфа: модель -> вьюха -> шаблон

представления - это такие функции

теперь, когда создаём соответствующую вьюху, сайт ругается: шаблон не существует! ничего, сейчас создадим :)

шаблон - это шаблон страницы (чтобы создавать посты, например). они на html
сохраняются в blog/templates/blog
создаём в этой папке post_list.html, и он показывается теперь на главной странице

git status, git add --all ., git status (проверить), git commit -m "сообщение", git push
на сайте: cd ~/my-first-blog, git pull
после этого нужно сделать reload


QuerySet - список объектов модели

python manage.py shell - интерактивная консоль Django (как python, но уже с функционалом Django)

проверить, какие есть посты - как опубликованные, так и не
from blog.models import Post
Post.objects.all()
должен получиться QuerySet

теперь нужно показать блог-записи, что такое автор
from django.contrib.auth.models import User
User.objects.all() - покажет всех юзеров
me = User.objects.get(username='Patience') - экземпляр суперъюзера

создать пост с текстом Test, заголовком Sample title и автором Patience
Post.objects.create(author=me, title='Sample title', text='Test')

Список QuerySet удобен для фильтрации объектов.
Post.objects.filter(author=me)
Post.objects.filter(title__contains='title')
двойное подчёркивание делает одну команду из параметра и того, что с ним делать

публикация записи из консоли ещё не опубликованной
post = Post.objects.get(title="Sample title") - выбираем нужную запись
post.publish() - публикуем

Сортировать по дате:
Post.objects.order_by('created_date')
противоположный порядок: '-created_date'

Можно сузить фильтрацию и отсортировать фильтр:
Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')

итак, модель Post определена в models.py
представление post_list определено в views.py
как отобразить записи в шаблоне HTML? (сейчас там только тестовые записи)

импортируем модель Post в views.py: from .models import Post (точка значит текущую директорию/текущее приложение)
в том же views.py фильтруем из QuerySet все опубликованные и сортируем по дате публикации:
posts = Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')

return render(request, 'blog/post_list.html', {'posts': posts})
request - запрос от пользователя (то, что мы обрабатываем)
второе в списке - шаблон
третье (словарь) в списке - набор постов (QuerySet), который отображается на странице

шаблон - это хтмл, в который вставляется код на питоне. вот так, например: {{ posts }}
но так покажется только переменная - сам список
поэтому надо каждое свойство каждого элемента показывать отдельно
{{post.text|linebreaksbr}} - вывести текст поста и строчки отделять с помощью <br>

css кладётся в blog/static/css/

Расширение шаблонов - когда мы используем одни и те же блоки HTML-кода для разных частей сайта
внутри html базового шаблона вставляется:
{% block content %}
{% endblock %}
этими же тэгами окружается в другом хтмле код, который должен быть на месте блока в базовом шаблоне
спереди файла, из которого вставляется кусок, пишется: {% extends 'blog/base.html' %}


удалить из QuerySet: Comic.objects.exclude(pic__contains="23")
